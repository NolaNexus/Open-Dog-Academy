#!/usr/bin/env python3
"""Generate deterministic index pages for MkDocs.

Why this exists
--------------
Hand-edited indexes drift. This script regenerates:

- docs/indexes/skills-index.md
- docs/indexes/class-guides-index.md
- docs/indexes/instructor-guides-index.md

The output is deterministic (no timestamps) so CI can enforce "indexes are up to date".

Usage
-----
  python3 scripts/generate_indexes.py           # write files
  python3 scripts/generate_indexes.py --check   # fail if files would change
"""

from __future__ import annotations

import argparse
import difflib
from pathlib import Path
from typing import Iterable, List, Tuple

from _lib.fs import write_text


REPO_ROOT = Path(__file__).resolve().parents[1]


def _read_text(path: Path) -> str:
    return path.read_text(encoding="utf-8", errors="replace")


def _first_h1_title(path: Path) -> str:
    """Best-effort: get the first H1 title text from a markdown file."""
    for ln in _read_text(path).splitlines():
        if ln.startswith("# "):
            return ln[2:].strip()
    return path.stem


def _iter_md(folder: Path) -> Iterable[Path]:
    if not folder.exists():
        return []
    return sorted([p for p in folder.rglob("*.md") if p.is_file()])


def _rel_from_indexes(target: Path) -> str:
    """Return a link path from docs/indexes to the target doc."""
    # indexes lives at docs/indexes -> one level up is docs/
    rel = target.relative_to(REPO_ROOT / "docs")
    return "../" + rel.as_posix()


def build_skills_index(docs_dir: Path) -> str:
    skills_dir = docs_dir / "skills"
    skill_files = [p for p in _iter_md(skills_dir) if p.name != "index.md"]
    # Skill IDs are the filename stem (e.g., OB_RECALL)
    items: List[Tuple[str, str]] = []
    for p in skill_files:
        sid = p.stem
        items.append((sid, _rel_from_indexes(p)))
    items.sort(key=lambda t: t[0])

    lines = [
        "# Open Dog Academy â€” Skill Index\n",
        "\n",
        "> Auto-generated by `scripts/generate_indexes.py`. Do not edit by hand.\n",
        "\n",
        "## Skills\n",
        "\n",
    ]
    lines += [f"- [{sid}]({href})\n" for sid, href in items]
    return "".join(lines)


def build_class_guides_index(docs_dir: Path) -> str:
    classes_dir = docs_dir / "classes"

    # Keep this page short and navigational:
    # - include only top-level guides in docs/classes/
    # - include suite index pages at docs/classes/*/index.md
    class_files: List[Path] = []

    # Top-level guides
    class_files += sorted([p for p in classes_dir.glob("*.md") if p.is_file()])

    # Suite indexes (one folder deep)
    for p in sorted(classes_dir.glob("*/index.md")):
        if p.is_file():
            class_files.append(p)

    # Stable ordering by relative path
    class_files = sorted(class_files, key=lambda p: p.relative_to(docs_dir).as_posix())

    lines = [
        "# Class Guides Index\n",
        "\n",
        "> Auto-generated by `scripts/generate_indexes.py`. Do not edit by hand.\n",
        "\n",
    ]
    for p in class_files:
        title = _first_h1_title(p)
        lines.append(f"- [{title}]({_rel_from_indexes(p)})\n")
    return "".join(lines)


def build_instructor_guides_index(docs_dir: Path) -> str:
    ig_dir = docs_dir / "instructor-guides"
    ig_files = [p for p in _iter_md(ig_dir) if p.name != "index.md"]
    ig_files.sort(key=lambda p: p.as_posix())

    lines = [
        "# Instructor Guides Index\n",
        "\n",
        "> Auto-generated by `scripts/generate_indexes.py`. Do not edit by hand.\n",
        "\n",
    ]
    for p in ig_files:
        title = _first_h1_title(p)
        lines.append(f"- [{title}]({_rel_from_indexes(p)})\n")
    return "".join(lines)


def _diff(a: str, b: str, fromfile: str, tofile: str) -> str:
    return "".join(
        difflib.unified_diff(
            a.splitlines(keepends=True),
            b.splitlines(keepends=True),
            fromfile=fromfile,
            tofile=tofile,
        )
    )


def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--check", action="store_true", help="Fail if any generated index would change.")
    ap.add_argument("--docs-root", default="docs", help="Docs root (default: docs).")
    args = ap.parse_args()

    docs_dir = (REPO_ROOT / args.docs_root).resolve()
    if not docs_dir.exists():
        print(f"Docs root not found: {docs_dir}")
        return 2

    out_dir = docs_dir / "indexes"
    out_dir.mkdir(parents=True, exist_ok=True)

    targets = {
        out_dir / "skills-index.md": build_skills_index(docs_dir),
        out_dir / "class-guides-index.md": build_class_guides_index(docs_dir),
        out_dir / "instructor-guides-index.md": build_instructor_guides_index(docs_dir),
    }

    changed = False
    for path, new_text in targets.items():
        old_text = _read_text(path) if path.exists() else ""
        if old_text != new_text:
            changed = True
            if args.check:
                print(_diff(old_text, new_text, fromfile=str(path), tofile=f"{path} (generated)"))
            else:
                write_text(path, new_text, mode=0o644)
                print(f"Wrote: {path.relative_to(REPO_ROOT).as_posix()}")

    if args.check and changed:
        print("ERROR: one or more index files are stale. Run: python3 scripts/generate_indexes.py")
        return 1

    if args.check:
        print("Indexes: OK")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
